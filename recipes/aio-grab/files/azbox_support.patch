--- a/main.c
+++ b/main.c
@@ -83,8 +83,8 @@ void fast_resize(unsigned char *source, unsigned char *dest, int xsource, int ys
 void (*resize)(unsigned char *source, unsigned char *dest, int xsource, int ysource, int xdest, int ydest, int colors);
 void combine(unsigned char *output, unsigned char *video, unsigned char *osd, int vleft, int vtop, int vwidth, int vheight, int xres, int yres);
 
-enum {UNKNOWN,PALLAS,VULCAN,XILLEON,BRCM7400,BRCM7401,BRCM7405,BRCM7335};
-char *stb_name[]={"unknown","Pallas","Vulcan","Xilleon","Brcm7400","Brcm7401","Brcm7405","Brcm7335"};
+enum {UNKNOWN,PALLAS,VULCAN,XILLEON,BRCM7400,BRCM7401,BRCM7405,BRCM7335,AZBOX863x,AZBOX865x};
+char *stb_name[]={"unknown","Pallas","Vulcan","Xilleon","Brcm7400","Brcm7401","Brcm7405","Brcm7335","Azbox863x","Azbox865x"};
 int stb_type=UNKNOWN;
 
 // main program
@@ -125,6 +125,8 @@ int main(int argc, char **argv) {
 		if (strcasestr(buf,"PALLAS")) stb_type=PALLAS;
 		if (strcasestr(buf,"XILLEON")) stb_type=XILLEON;
 		if (strcasestr(buf,"BCM7401") || strcasestr(buf,"BCMFB")) stb_type=BRCM7401;
+		if (strcasestr(buf,"EM863x")) stb_type=AZBOX863x;
+		if (strcasestr(buf,"EM865x")) stb_type=AZBOX865x;
 	}
 	pclose(pipe);
 
@@ -618,388 +620,504 @@ int main(int argc, char **argv) {
 
 void getvideo(unsigned char *video, int *xres, int *yres)
 {
+	unsigned char *luma = NULL, *chroma = NULL;
+	unsigned int stride = 0, res = 0;
+	int mem_fd, t;
+
 	printf("Grabbing Video ...\n");
-	int mem_fd;
-	//unsigned char *memory;
-	void *memory;
-	if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
-		printf("Mainmemory: can't open /dev/mem \n");
-		return;
-	}
 
-	unsigned char *luma, *chroma, *memory_tmp;
-	luma = (unsigned char *)malloc(1); // real malloc will be done later
-	chroma = (unsigned char *)malloc(1); // this is just to be sure it get initialized and free() will not segfaulting
-	memory_tmp = (unsigned char *)malloc(1);
-	int t,stride,res;
-	res = stride = 0;
-	char buf[256];
-	FILE *pipe;
+	if(stb_type == AZBOX863x || stb_type == AZBOX865x) {
+	
+	  unsigned char *infos = 0 ,*lyuv = 0, *ptr;
+	  int fd, len = 0, x, y;
+	  unsigned int	chroma_w, chroma_h;
+	  unsigned int	luma_w, luma_h;
+	  unsigned int	luma_width, chroma_width;
+	  unsigned int	luma_size_tile, chroma_size_tile, MemStart;
+	  unsigned char  *pluma;
+	  unsigned char  *pchroma;
+
+	   fd = open("/dev/frameyuv",O_RDWR);
+	   if(!fd) {
+		perror("/dev/frameyuv");		
+		return; 
+	   }
+
+	   infos = malloc(1920*1080*4);	 
+	   len = read(fd,infos,1920*1080*4); 
+
+	   if(len <= 0 ) {
+		 printf("No picture info %d\n",len);
+		 free(infos);
+		 close(fd);
+		 return;
+	    }
+		
+	    luma_w = (infos[0]<<24) | (infos[1]<<16) | (infos[2]<<8) | (infos[3]);  
+	    luma_h = (infos[4]<<24) | (infos[5]<<16) | (infos[6]<<8) | (infos[7]);  
+	    luma_width = (infos[8]<<24) | (infos[9]<<16) | (infos[10]<<8) | (infos[11]);  
+	    chroma_w = (infos[12]<<24) | (infos[13]<<16) | (infos[14]<<8) | (infos[15]);  
+	    chroma_h = (infos[16]<<24) | (infos[17]<<16) | (infos[18]<<8) | (infos[19]);  
+	    chroma_width = (infos[20]<<24) | (infos[21]<<16) | (infos[22]<<8) | (infos[23]);  
 
-	if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335)
-	{
-		// grab brcm7401 pic from decoder memory
-		const unsigned char* data = (unsigned char*)mmap(0, 100, PROT_READ, MAP_SHARED, mem_fd, 0x10100000);
-		if(!data)
-		{
-			printf("Mainmemory: <Memmapping failed>\n");
-			return;
-		}
+	    if(stb_type == AZBOX863x) {
+
+		luma_size_tile	= (((luma_w + 127)/128)*128) *  (((luma_h + 31)/32)*32);
+
+		chroma_size_tile	= (((chroma_w + 127)/128)*128) * (((chroma_h + 31)/32)*32); 
+	     } else {
 
-		int adr,adr2,ofs,ofs2,offset/*,vert_start,vert_end*/;
-		int xtmp,xsub,ytmp,t2,dat1;
+		luma_size_tile	= (((luma_w + 255)/256)*256) *  (((luma_h + 31)/32)*32);
+
+		chroma_size_tile	= (((chroma_w + 255)/256)*256) * (((chroma_h + 31)/32)*32); 
+	     }
+		
+	     pluma = infos + 24;
+	     pchroma = infos + 24 +luma_size_tile;
 		
-		//vert_start=data[0x1B]<<8|data[0x1A];
-		//vert_end=data[0x19]<<8|data[0x18];
-		stride=data[0x15]<<8|data[0x14];	
-		ofs=(data[0x28]<<8|data[0x27])>>4; // luma lines
-		ofs2=(data[0x2c]<<8|data[0x2b])>>4;// chroma lines
-		adr=(data[0x1f]<<24|data[0x1e]<<16|data[0x1d]<<8|data[0x1c])&0xFFFFFF00; // start of  videomem
-		adr2=(data[0x23]<<24|data[0x22]<<16|data[0x21]<<8|data[0x20])&0xFFFFFF00;
-		offset=adr2-adr;
+	     luma = malloc(luma_w * luma_h); 	 
+	     chroma = malloc(chroma_w * chroma_h * 2); 	  
 		
-		munmap((void*)data, 100);
+	     stride = luma_w;
+	     res = luma_h;
+		 
+		 
+	     ptr = luma;
+	     if(stb_type == AZBOX863x) { 
+		 /* save the luma buffer Y */
+		for (y = 0 ; y < luma_h ; y++) {
+	    	  for (x = 0 ; x < luma_w ; x++) {
+			 unsigned char* pixel = (pluma +\
+			 (x/128) * 4096 + (y/32) * luma_width * 32 +
+			 (x % 128) + (y % 32)*128);
+
+			*ptr++ = *pixel;
+			}
+		  }
+
+		ptr = chroma;
+
+		/* break chroma buffer into U & V components */
+		for (y = 0 ; y < chroma_h ; y++) {
+			for (x = 0 ; x < chroma_w*2 ; x++) {
+				unsigned char* pixel = (pchroma +\
+			    (x/128) * 4096 + (y/32) * chroma_width * 32 +
+				 (x % 128) + (y % 32)*128);
+
+		 *ptr++ = *pixel;
+		 }
+	       }
+	     } else if(stb_type == AZBOX865x) {
+
+		 /* save the luma buffer Y */
+		for (y = 0 ; y < luma_h ; y++) {
+	    	  for (x = 0 ; x < luma_w ; x++) {
+			 unsigned char* pixel = (pluma +\
+			 (x/256) * 8192 + (y/32) * luma_width * 32 +
+			 (x % 256) + (y % 32)*256);
+
+			*ptr++ = *pixel;
+			}
+		  }
 
-		pipe=fopen("/proc/stb/vmpeg/0/yres","r");
-		while (fgets(buf,sizeof(buf),pipe))
-			sscanf(buf,"%x",&res); 
-		fclose(pipe);
+		ptr = chroma;
 
-		if (!adr || !adr2)
-		{
-			*xres = stride;
-			*yres = res;
-			memset(video, 0, *xres * *yres * 3);
+		/* break chroma buffer into U & V components */
+		for (y = 0 ; y < chroma_h ; y++) {
+			for (x = 0 ; x < chroma_w*2 ; x++) {
+				unsigned char* pixel = (pchroma +\
+			    (x/256) * 8192 + (y/32) * chroma_width * 32 +
+				 (x % 256) + (y % 32)*256);
+
+		 *ptr++ = *pixel;
+		 }	
+
+
+	      }		
+	     }
+	   	free(infos);		
+		close(fd);
+	
+	 } else { // default , not Azbox receivers
+
+		
+		void *memory;
+		if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
+			printf("Mainmemory: can't open /dev/mem \n");
 			return;
 		}
 
-		//printf("Stride: %d Res: %d\n",stride,res);
-		//printf("Adr: %X Adr2: %X OFS: %d %d\n",adr,adr2,ofs,ofs2);
+		unsigned char *memory_tmp;
+		luma = (unsigned char *)malloc(1); // real malloc will be done later
+		chroma = (unsigned char *)malloc(1); // this is just to be sure it get initialized and free() will not segfaulting
+		memory_tmp = (unsigned char *)malloc(1);
+		char buf[256];
+		FILE *pipe;
 
-		luma = (unsigned char *)malloc(stride*(ofs));
-		chroma = (unsigned char *)malloc(stride*(ofs2+64));	
-
-		int memory_tmp_size = 0;
-		// grabbing luma & chroma plane from the decoder memory
-		if (stb_type == BRCM7401 || stb_type == BRCM7405)
+		if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335)
 		{
-			// on dm800/dm500hd we have direct access to the decoder memory
-			memory_tmp_size = offset + stride*(ofs2+64);
-			if(!(memory_tmp = (unsigned char*)mmap(0, memory_tmp_size, PROT_READ, MAP_SHARED, mem_fd, adr)))
+			// grab brcm7401 pic from decoder memory
+			const unsigned char* data = (unsigned char*)mmap(0, 100, PROT_READ, MAP_SHARED, mem_fd, 0x10100000);
+			if(!data)
 			{
 				printf("Mainmemory: <Memmapping failed>\n");
 				return;
 			}
-			
-			usleep(50000); 	// we try to get a full picture, its not possible to get a sync from the decoder so we use a delay
-							// and hope we get a good timing. dont ask me why, but every DM800 i tested so far produced a good
-							// result with a 50ms delay
-			
-		}
-		else if (stb_type == BRCM7400 || stb_type == BRCM7335)
-		{
-			int tmp_size = offset + stride*(ofs2+64);
-			if (tmp_size > 2 * DMA_BLOCKSIZE)
+
+			int adr,adr2,ofs,ofs2,offset/*,vert_start,vert_end*/;
+			int xtmp,xsub,ytmp,t2,dat1;
+		
+			//vert_start=data[0x1B]<<8|data[0x1A];
+			//vert_end=data[0x19]<<8|data[0x18];
+			stride=data[0x15]<<8|data[0x14];	
+			ofs=(data[0x28]<<8|data[0x27])>>4; // luma lines
+			ofs2=(data[0x2c]<<8|data[0x2b])>>4;// chroma lines
+			adr=(data[0x1f]<<24|data[0x1e]<<16|data[0x1d]<<8|data[0x1c])&0xFFFFFF00; // start of  videomem
+			adr2=(data[0x23]<<24|data[0x22]<<16|data[0x21]<<8|data[0x20])&0xFFFFFF00;
+			offset=adr2-adr;
+		
+			munmap((void*)data, 100);
+
+			pipe=fopen("/proc/stb/vmpeg/0/yres","r");
+			while (fgets(buf,sizeof(buf),pipe))
+				sscanf(buf,"%x",&res); 
+			fclose(pipe);
+
+			if (!adr || !adr2)
 			{
-				printf("Got invalid stride value from the decoder: %d\n", stride);
+				*xres = stride;
+				*yres = res;
+				memset(video, 0, *xres * *yres * 3);
 				return;
 			}
-			memory_tmp_size = DMA_BLOCKSIZE + 0x1000;
-			if (!(memory_tmp = (unsigned char*)mmap(0, memory_tmp_size, PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, SPARE_RAM)))
+
+			//printf("Stride: %d Res: %d\n",stride,res);
+			//printf("Adr: %X Adr2: %X OFS: %d %d\n",adr,adr2,ofs,ofs2);
+
+			luma = (unsigned char *)malloc(stride*(ofs));
+			chroma = (unsigned char *)malloc(stride*(ofs2+64));	
+
+			int memory_tmp_size = 0;
+			// grabbing luma & chroma plane from the decoder memory
+			if (stb_type == BRCM7401 || stb_type == BRCM7405)
 			{
-				printf("Mainmemory: <Memmapping failed>\n");
-				return;
+				// on dm800/dm500hd we have direct access to the decoder memory
+				memory_tmp_size = offset + stride*(ofs2+64);
+				if(!(memory_tmp = (unsigned char*)mmap(0, memory_tmp_size, PROT_READ, MAP_SHARED, mem_fd, adr)))
+				{
+					printf("Mainmemory: <Memmapping failed>\n");
+					return;
+				}
+			
+				usleep(50000); 	// we try to get a full picture, its not possible to get a sync from the decoder so we use a delay
+								// and hope we get a good timing. dont ask me why, but every DM800 i tested so far produced a good
+								// result with a 50ms delay
+			
 			}
-			volatile unsigned long *mem_dma;
-			if(!(mem_dma = (volatile unsigned long*)mmap(0, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, (stb_type == BRCM7400) ? 0x10c02000 : 0x10c01000)))
+			else if (stb_type == BRCM7400 || stb_type == BRCM7335)
 			{
-				printf("Mainmemory: <Memmapping failed>\n");
-				return;
-			}
+				int tmp_size = offset + stride*(ofs2+64);
+				if (tmp_size > 2 * DMA_BLOCKSIZE)
+				{
+					printf("Got invalid stride value from the decoder: %d\n", stride);
+					return;
+				}
+				memory_tmp_size = DMA_BLOCKSIZE + 0x1000;
+				if (!(memory_tmp = (unsigned char*)mmap(0, memory_tmp_size, PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, SPARE_RAM)))
+				{
+					printf("Mainmemory: <Memmapping failed>\n");
+					return;
+				}
+				volatile unsigned long *mem_dma;
+				if(!(mem_dma = (volatile unsigned long*)mmap(0, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, (stb_type == BRCM7400) ? 0x10c02000 : 0x10c01000)))
+				{
+					printf("Mainmemory: <Memmapping failed>\n");
+					return;
+				}
 
-			int i = 0;
-			int tmp_len = DMA_BLOCKSIZE;
-			for (i=0; i < tmp_size; i += DMA_BLOCKSIZE)
-			{
+				int i = 0;
+				int tmp_len = DMA_BLOCKSIZE;
+				for (i=0; i < tmp_size; i += DMA_BLOCKSIZE)
+				{
 				
-				unsigned long *descriptor = (void*)memory_tmp;
+					unsigned long *descriptor = (void*)memory_tmp;
 
-				if (i + DMA_BLOCKSIZE > tmp_size)
-					tmp_len = tmp_size - i;
+					if (i + DMA_BLOCKSIZE > tmp_size)
+						tmp_len = tmp_size - i;
 
-				//printf("DMACopy: %x (%d) size: %d\n", adr+i, i, tmp_len);
+					//printf("DMACopy: %x (%d) size: %d\n", adr+i, i, tmp_len);
 				
-				descriptor[0] = /* READ */ adr + i;
-				descriptor[1] = /* WRITE */ SPARE_RAM + 0x1000;
-				descriptor[2] = 0x40000000 | /* LEN */ tmp_len;
-				descriptor[3] = 0;
-				descriptor[4] = 0;
-				descriptor[5] = 0;
-				descriptor[6] = 0;
-				descriptor[7] = 0;
-				mem_dma[1] = /* FIRST_DESCRIPTOR */ SPARE_RAM;
-				mem_dma[3] = /* DMA WAKE CTRL */ 3;
-				mem_dma[2] = 1;
-				while (mem_dma[5] == 1)
-					usleep(2);
-				mem_dma[2] = 0;
+					descriptor[0] = /* READ */ adr + i;
+					descriptor[1] = /* WRITE */ SPARE_RAM + 0x1000;
+					descriptor[2] = 0x40000000 | /* LEN */ tmp_len;
+					descriptor[3] = 0;
+					descriptor[4] = 0;
+					descriptor[5] = 0;
+					descriptor[6] = 0;
+					descriptor[7] = 0;
+					mem_dma[1] = /* FIRST_DESCRIPTOR */ SPARE_RAM;
+					mem_dma[3] = /* DMA WAKE CTRL */ 3;
+					mem_dma[2] = 1;
+					while (mem_dma[5] == 1)
+						usleep(2);
+					mem_dma[2] = 0;
 		
-			}
+				}
 
-			munmap((void *)mem_dma, 0x1000);
-			memory_tmp+=0x1000;
-		}
+				munmap((void *)mem_dma, 0x1000);
+				memory_tmp+=0x1000;
+			}
 
-		t=t2=dat1=0;
-		int chr_luma_stride = 0x40;
+			t=t2=dat1=0;
+			int chr_luma_stride = 0x40;
 
-		if (stb_type == BRCM7405)
-			chr_luma_stride *= 2;
+			if (stb_type == BRCM7405)
+				chr_luma_stride *= 2;
 
-		xsub=chr_luma_stride;
-		// decode luma & chroma plane or lets say sort it
-		for (xtmp=0; xtmp < stride; xtmp += chr_luma_stride)
-		{
-			if ((stride-xtmp) <= chr_luma_stride)
-				xsub=stride-xtmp;
+			xsub=chr_luma_stride;
+			// decode luma & chroma plane or lets say sort it
+			for (xtmp=0; xtmp < stride; xtmp += chr_luma_stride)
+			{
+				if ((stride-xtmp) <= chr_luma_stride)
+					xsub=stride-xtmp;
 
-			dat1=xtmp;
-			for (ytmp = 0; ytmp < ofs; ytmp++) 
+				dat1=xtmp;
+				for (ytmp = 0; ytmp < ofs; ytmp++) 
+				{
+					memcpy(luma+dat1,memory_tmp+t,xsub); // luma
+					t+=chr_luma_stride;
+					dat1+=stride;
+				}
+			}
+			// Hmm apparently lumastride == chromastride?
+			xsub=chr_luma_stride;
+			for (xtmp=0; xtmp < stride; xtmp += chr_luma_stride)
 			{
-				memcpy(luma+dat1,memory_tmp+t,xsub); // luma
-				t+=chr_luma_stride;
-				dat1+=stride;
+				if ((stride-xtmp) <= chr_luma_stride)
+					xsub=stride-xtmp;
+
+				dat1=xtmp;
+				for (ytmp = 0; ytmp < ofs2; ytmp++) 
+				{
+					memcpy(chroma+dat1,memory_tmp+offset+t2,xsub); // chroma
+					t2+=chr_luma_stride;
+					dat1+=stride;
+				}
 			}
-		}
-		// Hmm apparently lumastride == chromastride?
-		xsub=chr_luma_stride;
-		for (xtmp=0; xtmp < stride; xtmp += chr_luma_stride)
-		{
-			if ((stride-xtmp) <= chr_luma_stride)
-				xsub=stride-xtmp;
+			munmap(memory_tmp, memory_tmp_size);
 
-			dat1=xtmp;
-			for (ytmp = 0; ytmp < ofs2; ytmp++) 
+			int count = (stride*ofs) >> 2;
+			unsigned char* p = luma;
+			for (t=count; t != 0; --t)
 			{
-				memcpy(chroma+dat1,memory_tmp+offset+t2,xsub); // chroma
-				t2+=chr_luma_stride;
-				dat1+=stride;
+				SWAP(p[0], p[3]);
+				SWAP(p[1], p[2]);
+				p += 4;
 			}
-		}
-		munmap(memory_tmp, memory_tmp_size);
-
-		int count = (stride*ofs) >> 2;
-		unsigned char* p = luma;
-		for (t=count; t != 0; --t)
-		{
-			SWAP(p[0], p[3]);
-			SWAP(p[1], p[2]);
-			p += 4;
-		}
-		count = (stride*(ofs>>1)) >> 2;
-		p = chroma;
-		for (t=count; t != 0; --t)
-		{
-			SWAP(p[0], p[3]);
-			SWAP(p[1], p[2]);
-			p += 4;
-		}
-	} else if (stb_type == XILLEON)
-	{
-		// grab xilleon pic from decoder memory
-		pipe = fopen("/proc/stb/vmpeg/0/xres","r");
-		if (pipe)
-		{
-			while (fgets(buf,sizeof(buf),pipe))
+			count = (stride*(ofs>>1)) >> 2;
+			p = chroma;
+			for (t=count; t != 0; --t)
 			{
-				sscanf(buf,"%x",&stride); 
+				SWAP(p[0], p[3]);
+				SWAP(p[1], p[2]);
+				p += 4;
 			}
-			fclose(pipe);
-		}
-		pipe = fopen("/proc/stb/vmpeg/0/yres","r");
-		if (pipe)
+		} else if (stb_type == XILLEON)
 		{
-			while (fgets(buf,sizeof(buf),pipe))
+			// grab xilleon pic from decoder memory
+			pipe = fopen("/proc/stb/vmpeg/0/xres","r");
+			if (pipe)
 			{
-				sscanf(buf,"%x",&res); 
+				while (fgets(buf,sizeof(buf),pipe))
+				{
+					sscanf(buf,"%x",&stride); 
+				}
+				fclose(pipe);
+			}
+			pipe = fopen("/proc/stb/vmpeg/0/yres","r");
+			if (pipe)
+			{
+				while (fgets(buf,sizeof(buf),pipe))
+				{
+					sscanf(buf,"%x",&res); 
+				}
+				fclose(pipe);
 			}
-			fclose(pipe);
-		}
 
-		printf("ML - 1\n");
-		if(!(memory = (unsigned char*)mmap(0, 1920*1152*6, PROT_READ, MAP_SHARED, mem_fd, 0x6000000)))
-		{
-			printf("Mainmemory: <Memmapping failed>\n");
-			return;
-		}
+			printf("ML - 1\n");
+			if(!(memory = (unsigned char*)mmap(0, 1920*1152*6, PROT_READ, MAP_SHARED, mem_fd, 0x6000000)))
+			{
+				printf("Mainmemory: <Memmapping failed>\n");
+				return;
+			}
 		
-		luma = (unsigned char *)malloc(1920*1152);
-		chroma = (unsigned char *)malloc(1920*576);
+			luma = (unsigned char *)malloc(1920*1152);
+			chroma = (unsigned char *)malloc(1920*576);
 		
-		int offset=1920*1152*5;	// offset for chroma buffer
+			int offset=1920*1152*5;	// offset for chroma buffer
 		
-		const unsigned char* frame_l = memory; // luma frame from video decoder
-		const unsigned char* frame_c = memory + offset; // chroma frame from video decoder
+			const unsigned char* frame_l = memory; // luma frame from video decoder
+			const unsigned char* frame_c = memory + offset; // chroma frame from video decoder
 		
-		int xtmp,ytmp,ysub,xsub;
-		const int ypart=32;
-		const int xpart=128;
-		int oe2=0;
-		int ysubcount=res/32;
-		int ysubchromacount=res/64;
-
-		// "decode" luma/chroma, there are 128x32pixel blocks inside the decoder mem
-		for (ysub=0; ysub<=ysubcount; ysub++) 
-		{
-			for (xsub=0; xsub<15; xsub++) // 1920/128=15
+			int xtmp,ytmp,ysub,xsub;
+			const int ypart=32;
+			const int xpart=128;
+			int oe2=0;
+			int ysubcount=res/32;
+			int ysubchromacount=res/64;
+
+			// "decode" luma/chroma, there are 128x32pixel blocks inside the decoder mem
+			for (ysub=0; ysub<=ysubcount; ysub++) 
 			{
-				// Even lines
-				for (ytmp=0; ytmp<ypart; ytmp++)
+				for (xsub=0; xsub<15; xsub++) // 1920/128=15
 				{
-					int extraoffset = (stride*(ytmp+(ysub*ypart)));
-					int destx = xsub*xpart;
-					int overflow = (destx + xpart) - stride;
-					if (overflow <= 0)
-					{
-						// We copy a bit too much...
-						memcpy(luma + destx + extraoffset, frame_l, xpart);
-					}
-					else if (overflow < xpart)
+					// Even lines
+					for (ytmp=0; ytmp<ypart; ytmp++)
 					{
-                                                memcpy(luma + destx + extraoffset, frame_l, overflow);
+						int extraoffset = (stride*(ytmp+(ysub*ypart)));
+						int destx = xsub*xpart;
+						int overflow = (destx + xpart) - stride;
+						if (overflow <= 0)
+						{
+							// We copy a bit too much...
+							memcpy(luma + destx + extraoffset, frame_l, xpart);
+						}
+						else if (overflow < xpart)
+						{
+		                                        memcpy(luma + destx + extraoffset, frame_l, overflow);
+						}
+						frame_l += xpart;
 					}
-					frame_l += xpart;
 				}
-			}
-			++ysub; // dirty...
-			for (xsub=0; xsub<15; xsub++) // 1920/128=15
-			{
-				// Odd lines (reverts 64 byte block?)
-				// Only luminance
-				for (ytmp=0; ytmp<ypart; ytmp++)
+				++ysub; // dirty...
+				for (xsub=0; xsub<15; xsub++) // 1920/128=15
 				{
-					int extraoffset = (stride*(ytmp+(ysub*ypart)));
-					int destx = xsub*xpart;
-					int overflow = (destx + xpart) - stride;
-					if (overflow <= 0)
-					{
-						// We copy a bit too much...
-						memcpy(luma + destx + extraoffset + 64, frame_l, 64);
-						memcpy(luma + destx + extraoffset, frame_l + 64, 64);
-					}
-					else if (overflow < xpart)
+					// Odd lines (reverts 64 byte block?)
+					// Only luminance
+					for (ytmp=0; ytmp<ypart; ytmp++)
 					{
-						if (overflow > 64)
+						int extraoffset = (stride*(ytmp+(ysub*ypart)));
+						int destx = xsub*xpart;
+						int overflow = (destx + xpart) - stride;
+						if (overflow <= 0)
 						{
-							memcpy(luma + destx + extraoffset + 64, frame_l, overflow-64);
+							// We copy a bit too much...
+							memcpy(luma + destx + extraoffset + 64, frame_l, 64);
 							memcpy(luma + destx + extraoffset, frame_l + 64, 64);
 						}
-						else
+						else if (overflow < xpart)
 						{
-							memcpy(luma + destx + extraoffset, frame_l + 64, overflow);
+							if (overflow > 64)
+							{
+								memcpy(luma + destx + extraoffset + 64, frame_l, overflow-64);
+								memcpy(luma + destx + extraoffset, frame_l + 64, 64);
+							}
+							else
+							{
+								memcpy(luma + destx + extraoffset, frame_l + 64, overflow);
+							}
 						}
+						frame_l += xpart;
 					}
-					frame_l += xpart;
 				}
 			}
-		}
 
-		// Chrominance (half resolution)
-		ysubcount /= 2;
-		for (ysub=0; ysub<=ysubcount; ysub++) 
-		{
-			for (xsub=0; xsub<15; xsub++) // 1920/128=15
+			// Chrominance (half resolution)
+			ysubcount /= 2;
+			for (ysub=0; ysub<=ysubcount; ysub++) 
 			{
-				// Even lines
-				for (ytmp=0; ytmp<ypart; ytmp++)
+				for (xsub=0; xsub<15; xsub++) // 1920/128=15
 				{
-					int extraoffset = (stride*(ytmp+(ysub*ypart)));
-					int destx = xsub*xpart;
-					int overflow = (destx + xpart) - stride;
-					if (overflow <= 0)
+					// Even lines
+					for (ytmp=0; ytmp<ypart; ytmp++)
 					{
-						memcpy(chroma + destx + extraoffset, frame_c, xpart);
-					}
-					else if (overflow < xpart)
-					{
-                                                memcpy(chroma + destx + extraoffset, frame_c, overflow);
+						int extraoffset = (stride*(ytmp+(ysub*ypart)));
+						int destx = xsub*xpart;
+						int overflow = (destx + xpart) - stride;
+						if (overflow <= 0)
+						{
+							memcpy(chroma + destx + extraoffset, frame_c, xpart);
+						}
+						else if (overflow < xpart)
+						{
+		                                        memcpy(chroma + destx + extraoffset, frame_c, overflow);
+						}
+						frame_c += xpart;
 					}
-					frame_c += xpart;
 				}
-			}
-			++ysub; // dirty...
-			for (xsub=0; xsub<15; xsub++) // 1920/128=15
-			{
-				// Odd lines (reverts 64 byte block?)
-				// Only luminance
-				for (ytmp=0; ytmp<ypart; ytmp++)
+				++ysub; // dirty...
+				for (xsub=0; xsub<15; xsub++) // 1920/128=15
 				{
-					int extraoffset = (stride*(ytmp+(ysub*ypart)));
-					int destx = xsub*xpart;
-					int overflow = (destx + xpart) - stride;
-					if (overflow <= 0)
+					// Odd lines (reverts 64 byte block?)
+					// Only luminance
+					for (ytmp=0; ytmp<ypart; ytmp++)
 					{
-						// We copy a bit too much...
-						memcpy(chroma + destx + extraoffset + 64, frame_c, 64);
-						memcpy(chroma + destx + extraoffset, frame_c + 64, 64);
-					}
-					else if (overflow < xpart)
-					{
-						if (overflow > 64)
+						int extraoffset = (stride*(ytmp+(ysub*ypart)));
+						int destx = xsub*xpart;
+						int overflow = (destx + xpart) - stride;
+						if (overflow <= 0)
 						{
-							memcpy(chroma + destx + extraoffset + 64, frame_c, overflow-64);
+							// We copy a bit too much...
+							memcpy(chroma + destx + extraoffset + 64, frame_c, 64);
 							memcpy(chroma + destx + extraoffset, frame_c + 64, 64);
 						}
-						else
+						else if (overflow < xpart)
 						{
-							memcpy(chroma + destx + extraoffset, frame_c + 64, overflow);
+							if (overflow > 64)
+							{
+								memcpy(chroma + destx + extraoffset + 64, frame_c, overflow-64);
+								memcpy(chroma + destx + extraoffset, frame_c + 64, 64);
+							}
+							else
+							{
+								memcpy(chroma + destx + extraoffset, frame_c + 64, overflow);
+							}
 						}
+						frame_c += xpart;
 					}
-					frame_c += xpart;
 				}
 			}
-		}
 
 
-		munmap(memory, 1920*1152*6);
+			munmap(memory, 1920*1152*6);
 
-	} else if (stb_type == VULCAN || stb_type == PALLAS)
-	{
-		// grab via v4l device (ppc boxes)
+		} else if (stb_type == VULCAN || stb_type == PALLAS)
+		{
+			// grab via v4l device (ppc boxes)
 		
-		memory_tmp = (unsigned char *)malloc(720 * 576 * 3 + 16);
+			memory_tmp = (unsigned char *)malloc(720 * 576 * 3 + 16);
 		
-		int fd_video = open(VIDEO_DEV, O_RDONLY);
-		if (fd_video < 0)
-		{
-			printf("could not open /dev/video");
-			return;
-		}	 
+			int fd_video = open(VIDEO_DEV, O_RDONLY);
+			if (fd_video < 0)
+			{
+				printf("could not open /dev/video");
+				return;
+			}	 
 		
-		int r = read(fd_video, memory_tmp, 720 * 576 * 3 + 16);
-		if (r < 16)
-		{
-			fprintf(stderr, "read failed\n");
+			int r = read(fd_video, memory_tmp, 720 * 576 * 3 + 16);
+			if (r < 16)
+			{
+				fprintf(stderr, "read failed\n");
+				close(fd_video);
+				return;
+			}
 			close(fd_video);
-			return;
-		}
-		close(fd_video);
 		
-		int *size = (int*)memory_tmp;
-		stride = size[0];
-		res = size[1];
+			int *size = (int*)memory_tmp;
+			stride = size[0];
+			res = size[1];
 		
-		luma = (unsigned char *)malloc(stride * res);
-		chroma = (unsigned char *)malloc(stride * res);
+			luma = (unsigned char *)malloc(stride * res);
+			chroma = (unsigned char *)malloc(stride * res);
 		
-		memcpy (luma, memory_tmp + 16, stride * res);
-		memcpy (chroma, memory_tmp + 16 + stride * res, stride * res);
+			memcpy (luma, memory_tmp + 16, stride * res);
+			memcpy (chroma, memory_tmp + 16 + stride * res, stride * res);
 		
-		free(memory_tmp);
-	}
+			free(memory_tmp);
+		}
 
-	close(mem_fd);	
-	
+		close(mem_fd);	
+	}
 	int Y, U, V, y ,x, out1, pos, RU, GU, GV, BV, rgbstride;
 	Y=U=V=0;
 		
-- 
